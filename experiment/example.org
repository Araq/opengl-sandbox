#+TITLE: Implementation

* TODO
** TODO glm port for the typechecker
** TODO typed and untyped macros
** TODO two pass macro
** TODO type injection
** TODO gathering used types and procedures
** TODO type normalization
** TODO translation from Nim IR to GLSL
** TODO identifier transformation
** TODO AST pattern matching
** TODO matching the for construct

* base example

# Why I chose an example for explanation?
To my knowledge it is easiest to understand a new topic with a
concrete example.  Therefore I would like to explain the inernals of
the compiler with an example.  The example that I choose should be an
example that is easy to understand, could be part of a real program
and it should cover many features that I want to support.

# What is the example about?
In listing ref:base-example I show an example that I want to make
executable over the course of this mater thesis.  It renders a mesh
with texture mapping and vertex-normals.  In the vertex shader the
lighting is calculated by a loop that iterates all light sources.

Features this example covers:

  * uniforms
  * attributes
  * non-builtin types (Light)
  * for loop (iterator)

#+caption: Base Example label:base-example
#+BEGIN_SRC nim
import glm, macros

macro render(args: varargs[untyped]): untyped =
  for arg in args:
    echo arg.treeRepr

type
  Mesh[T] = object
  Framebuffer[T] = object
  Texture2D = object

type
  MyFragmentType = object
    color: Vec4f

  MyVertexType = object
    position_os: Vec4f
    normal_os: Vec4f
    texCoord: Vec2f

  Light = object
    position_ws : Vec4f
    color : Vec4f

  MyMesh        = Mesh[MyVertexType]
  MyFramebuffer = Framebuffer[MyFragmentType]

var myTexture: Texture2D
var mesh: MyMesh
var framebuffer: MyFramebuffer
var mvp: Mat4f

var M,V,P: Mat4f
var lights: array[10,Light]

framebuffer.render(mesh) do (v, gl):
  gl.Position     = (P * V * M) * v.position_os
  let position_cs = V*M*v.position_os
  let normal_cs   = inverse(transpose(V*M)) * v.normal_os
  var lighting: Vec4f

  ## rasterize

  for light in lights:
    let light_position_cs = V * light.position_ws
    let light_direction_cs = light_position_cs-position_cs
    let light_intensity = dot(light_direction_cs, normal_cs)
    lighting += light_intensity * light.color

  let textureSample = texture(myTexture, v.texCoord)
  result.color = textureSample * lighting

#+END_SRC

#+RESULTS:
: HalloWelt...

# how the nim typechecker works, and why I create the outer macro.
The typechecker in Nim can only check types of the Nim programming
language with semantics of the Nim programming language.  The
typechecking algorithm itself is not scriptable.  Therefore I need to
map glsl semantics somehow to the Nim programming language.  Most glsl
types map nicely to the types defined in the glm library.  Then the
glsl part needs to have some context for the typechecker that I inject
with a two layer macro (where the full will you talk about it).

From here on I assume that all types of glsl also work flawlessly in
Nim.  For more details on how this works see the glsl section.

In order for the typecheck to be able to resolve all symbols correctly
I use the pattern with a two layer macro.  The outer macro takes a
non-typechecked AST, and then generates an AST that is capabale to be
fully typechecked.  The then generated AST is a statment to a typed
macro.  With this pattern it is possible to introduce symbols that
only exist in the embedded DSL.  In the listings ref:two-layer-macro-a
and ref:two-layer-macro-a you see how I introduce the symbol ~gl~ with
this pattern.

#+caption: Two Layer Macro A label:two-layer-macro-a
#+BEGIN_SRC nim
framebuffer.render(mesh) do (v):
  gl.Position     = (P * V * M) * v.position_os
  #[...]#
#+END_SRC

This will be transformed into the following statement:

#+caption: Two Layer Macro B label:two-layer-macro-b
#+BEGIN_SRC nim
block:  # A code block to create a new variable scope.
  gl: var GlShaderContext {.inject.} # inject to prevent symbol hiding hygienic
  render_inner(framebuffer, mesh) do (v: MyVertexType) -> MyFragmentType:
    gl.Position     = (P * V * M) * v.position_os
    #[ ... ]#
#+END_SRC

Now the type checker can resolve all symbols from the inner body of
this macro.  The typechecked AST is reprinted here again in nim representation.

#+BEGIN_EXAMPLE

do (v: MyVertexType; gl: var GlShaderContext) -> MyFragmentType:
  gl.Position = P * V * M * v.position_os
  let position_cs = V * M * v.position_os
  let normal_cs = inverse(transpose(V * M)) * v.normal_os
  var lighting: Vec4f
  block tmp346054:
      var light: Light
      var i = 0
      if i <= 9:
        block tmp346055:
            while true:
              light = lights[i]
              let light_position_cs = V * light.position_ws
              let light_direction_cs = light_position_cs - position_cs
              let light_intensity = dot(light_direction_cs, normal_cs)
              lighting += light_intensity * light.color
              if 9 <= i:
                break tmp346055
              inc(i, 1)
  let textureSample = texture(myTexture, v.texCoord, 0.0)
  result.color = textureSample * lighting

#+END_EXAMPLE

For representation alone it is not obvious that it is now a tree
of resolved symbols, but the full tree would be too large to be shown
here. This is only the last last line printed in tree representation:

#+BEGIN_EXAMPLE
  Asgn
    DotExpr
      Sym "result"
      Sym "color"
    Infix
      Sym "*"
      Sym "textureSample"
      Sym "lighting"

#+END_EXAMPLE

I don't know what to do to prevent that the for loop becomes a while
loop.  Should I filter for this while loop and translate it back to a
for loop in glsl? Or should I just translate into a while loop and
hope the glsl compiler will be able to unroll it anyway?  Glsl
performance might really suffer from dynamically sized arrays, but
this should really be tested,  I did not test it at all yet.

** Extraction of Meta Information

** passing uniforms


Uniforms are split into two different kinds of uniforms: ~samplers~
and ~rest~.  Samplers depend on the OpenGL state and are passed
differently that the ~rest~.  Everything that is not a sampler can be
packed into a single uniform buffer object.  Samplers get their value
assigned in the shader.



The solution is that textures are passed uni

Uniforms are separated into two types of uniforms.  Samplers and Non sam


** preventing the `iterator items` expansion, or matching against it?

The metainformation that is important for the next steps are the
following:

 * split vertex and fragment shader parts
 * extract all used uniforms
 * extract all used attributes and in witch shader they are used
 * extract identifiers that are used as varyings.
 * used types (non glsl types)

*** Extract Vertex and Fragment Shader

# the magic comment
Currently the vertex shader and the fragment shader is the code is
sparated by a magic comment ~## rasterize~. I don't necessarily like
this magic comment, and I think eventually it will go away, but for
now it is how the separation is explicitly specified. All statements
fore it will be translated into a vertex shader, and all statements
after it will be translated into a fragment shader.  This is very
simple to implement.

**** TODO introduce name for the argument of the macro (the AST).

The ast, the argument of the macro will from now on be called /body/.

# traverse the AST (uniforms)
Now the AST can be scanned for all used symbols. A symbol of a
variable that has not been defined locally in the argument of the
macro has to be a uniform. A symbol that has been defined in the

# How do I get metainformation.
# What uniforms are used
# What attributes are used
# how do I translate identifiers

** preventing the `iterator items` expansion, or matching against it?

From here on the Nim code should be translated directly into
GLSL. Even though I haven't talked at all about the shader stage
separation at all, and this is important.

* symbol table

| symbol             | kind         | glsl repr        | type                    |
|--------------------+--------------+------------------+-------------------------|
| inversse           | BuiltinProc  | inversse         |                         |
| transpose          | BuiltinProc  | transpose        |                         |
| texture            | BuiltinProc  | texture          |                         |
| dot                | BuiltinProc  | dot              |                         |
| vec4f              | BuiltinProc  | vec4             |                         |
| M                  | Uniform      | M                | Mat[4,float32]          |
| V                  | Uniform      | V                | Mat[4,float32]          |
| P                  | Uniform      | P                | Mat[4,float32]          |
| lights             | Uniform      | lights           | array[3,Light]          |
| v.position_os      | Attribute    | v_positionos     | Vec[4,float32]          |
| v.normal_os        | Attribute    | v_normalos       | Vec[4,float32]          |
| v.texCoord         | Attribute    | v_texCoord       | Vec[2,float32]          |
| result.color       | Result       | result_color     | Vec[4,float32]          |
| Vec4f              | Type         | vec4             | Vec[4,float32]          |
| Mat4f              | Type         | mat4             | Mat[4,float32]          |
| float32            | Type         | float            | float32                 |
| light              | LoopIt       | ???              | ???                     |
| position_ws        | Member       | positionws       | Light -> Vec[4,float32] |
| color              | Member       | color            | Light -> Vec[4,float32] |
| position_cs        | LocalVar     | positioncs       | Vec[4,float32]          |
| normal_cs          | LocalVar     | normalcs         | Vec[4,float32]          |
| lighting           | LocalVar     | lighting         | Vec[4,float32]          |
| light_position_cs  | LocalVar     | lightpositioncs  | Vec[4,float32]          |
| light_direction_cs | LocalVar     | lightdirectioncs | Vec[4,float32]          |
| light_intensity    | LocalVar     | lightintensity   | float32                 |
| textureSample      | LocalVar     | textureSample    | Vec[4,float32]          |
| t1                 | Intermediate | temp_1           | Mat[4,float32]          |
| t2                 | Intermediate | temp_2           | Mat[4,float32]          |
| t3                 | Intermediate | temp_3           | Mat[4,float32]          |
| t4                 | Intermediate | temp_4           | float32                 |
| t5                 | Intermediate | temp_5           | Vec[4,float32]          |
| t6                 | Intermediate | temp_6           | Vec[4,float32]          |
| t7                 | Intermediate | temp_7           | Vec[4,float32]          |

* intermediate representation

#+BEGIN_SRC

(Block
  (Asgn `gl.Position` (Mult `P` `V` `M` `v.position_os`))
  (Asgn `position_cs` (Mult `V` `M` `v.position_os`))
  (Asgn `t1` (Mult `V` `M`))
  (Asgn `t2` (Call `transpose` `t1`))
  (Asgn `t3` (Call `inverse` `t2`))
  (Asgn `normal_cs` (Mult `t3` `v.normal_os`))
  (Asgn `lighting`  (Call `vec4f` 0))
  (Loop `light` `lights`
    (Asgn `t4` (Dot `light` `position_ws`))
    (Asgn `light_position_cs` (Mult `V` `t4`))
    (Asgn `t5` (Neg `position_cs`))
    (Asgn `light_direction_cs` (Add `t5` `light_position_cs`))
    (Asgn `light_intensity`  (Call `dot` `light_direction_cs` `normal_cs`))
    (Asgn `t6` (Dot `light` `color`))
    (Asgn `t7` (Mult `light_intensity` `t6`))
    (Asgn `lighting` (Add `lighting` `t7`))
  )
  (Asgn `textureSample` (Call `texture` `myTexture` `v.texCoord`))
  (Asgn `result.color` (Mult `texturesample` `lighting`))
)

#+END_SRC


all symbols in the loop body need to be in a group, because a variable
in the loop body can't be passed down to the fragment shader.

* all <= relations

| `gl.Position`        | `P`                  |
| `gl.Position`        | `V`                  |
| `gl.Position`        | `M`                  |
| `gl.Position`        | `v.position_os`      |
| `position_cs`        | `V`                  |
| `position_cs`        | `M`                  |
| `position_cs`        | `v.position_os`      |
| `t1`                 | `V`                  |
| `t2`                 | `M`                  |
| `t2`                 | `t1`                 |
| `t3`                 | `t2`                 |
| `normal_cs`          | `t3`                 |
| `normal_cs`          | `v.normal_os`        |
| `t4`                 | `light`              |
| `t4`                 | `light`              |
| `light_position_cs`  | `V`                  |
| `light_position_cs`  | `t4`                 |
| `t5`                 | `position_cs`        |
| `light_direction_cs` | `t5`                 |
| `light_direction_cs` | `light_position_cs`  |
| `light_intensity`    | `light_direction_cs` |
| `light_intensity`    | `normal_cs`          |
| `t6`                 | `light`              |
| `t6`                 | `color`              |
| `t7`                 | `light_intensity`    |
| `t7`                 | `t6`                 |
| `lighting`           | `lighting`           |
| `lighting`           | `t7`                 |
| `textureSample`      | `myTexture`          |
| `textureSample`      | `v.texCoord`         |
| `result.color`       | `texturesample`      |
| `result.color`       | `lighting`           |


#+BEGIN_SRC nim

type
  IRNodeKinds = enum
    irBlock
    irAsgn
    irDot
    irMult
    irAdd
    irNeg
    irCall
    irDecl
    irLoop

#+END_SRC

* generated shader source

This is how the generated shader source could/should look like. This
code is hand translated, so it is not guaranteed that the final
compiler will generate exactly this shader code, but at the current
state of development it looks like this could be done.

** TODO talk about shader stage separation

#+BEGIN_SRC glsl
#version 450
uniform mat4 P;
uniform mat4 V;
uniform mat4 M;

in layout(location = 0) vec4 in_v_positionos;
in layout(location = 1) vec4 in_v_normalos;
in layout(location = 2) vec2 in_v_texCoord;

out layout(location = 0) vec4 out_positioncs;
out layout(location = 1) vec4 out_normalcs;
out layout(location = 2) vec2 out_v_texCoord;

void main() {
  vec4 v_positionos = in_v_positionos;
  vec4 v_normalos = in_v_positionos;
  vec2 v_texCoord = in_v_texCoord;

  gl_Position = P * V * M * v_positionos;
  vec4 positioncs = V * M * v_positionos;
  vec4 normalcs   = inverse(transpose(V * M)) * v_normalos;

  out_positioncs = positioncs;
  out_normalcs = normalcs;
  out_v_texCoord = v_texCoord;
}
#+END_SRC

#+BEGIN_SRC glsl
#version 450

uniform mat4 P;
uniform mat4 V;
uniform mat4 M;
uniform sampler2D myTexture;

struct Light {
  vec4 positionws;
  vec4 color;
};

uniform Light lights[10];

in layout(location = 0) vec4 in_positioncs;
in layout(location = 1) vec4 in_normalcs;
in layout(location = 2) vec2 in_v_texCoord;

out layout(location = 0) vec4 result_color;

void main() {
  vec4 positioncs = in_positioncs;
  vec4 normalcs = in_normalcs;
  vec2 v_texCoord = in_v_texCoord;

  vec4 lighting = vec4(0);

  for(int i = 0; i < 10; ++i) {
    Light light = lights[i];
    vec4 lightpositioncs = V * light.positionws;
    vec4 lightdirectioncs = lightpositioncs - positioncs;
    float light_intensity = dot(lightdirectioncs, normalcs);
    lighting += light_intensity * light.color;
  }

  vec4 textureSample = texture(myTexture, v_texCoord, 0.0);
  result_color = textureSample * lighting;
}
#+END_SRC

 * how do I map symbols/identifiers.

I take out all the _ underscore charactors. They do not have any
meaning in Nim anyway. Then I can use it for my own personal
separation in glsl.


additionally to the shader code, the following OpenGL commands should be
generated:

 * glCompileShader
 * glLinkShader
 * glUninform
 * glAttribute
 * glDraw
 * etc (details you don't wanna know, but I have to fill pages, maybe
   you will get to know them even if you don't want to)


* other example

#+BEGIN_SRC nim
render myVA: (vs, gl) ->

    # face normal test
    let normal = normalize cross(v[0].pos - v[1].pos, v[0].pos - v[2].pos)
    for 1..5:
        for 1..3:
            emit proj * view * model * v.position
        endPrimitive

    # per vertex -> line in vertex normal dir
    var color: Vec3
    var normal: Vec3
    for v in vs:
        for i in 0..1:
            normal = v.normal
            color = if i == 0: vec3(1,0,0) else: vec3(0,0,1)
            emit proj * view * model * (v.position + vec4(v.normal, 0) * i)
        endPrimitive

    result.color = dot(color, normal)


    # per vertex -> line in vertex normal dir
    for v in vs:
        for i in 0..1:
            gl.Position = proj * view * model * (v.position + vec4(v.normal, 0) * i)
            let normal = v.normal
            let color = if i == 0: vec3(1,0,0) else: vec3(0,0,1)
            result.color = dot(color,normal)
            emitVertex()
        endPrimitive(GL_LINE_STRIP)


    # per vertex -> line in vertex normal dir
    for v in vs:

        gl.Position = proj * view * model * (v.position + vec4(v.normal, 0) * i)
        let normal = v.normal
        let color = vec3(1,0,0)
        result.color = dot(color,normal)
        emitVertex()

        gl.Position = proj * view * model * (v.position + vec4(v.normal, 0) * i)
        let normal = v.normal
        let color = vec3(0,0,1)
        result.color = dot(color,normal)
        emitVertex()

        endPrimitive(GL_LINE_STRIP)

#+END_SRC
