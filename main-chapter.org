#+TITLE: Implementation

* TODO
** TODO glm port for the typechecker
** TODO typed and untyped macros
** TODO two pass macro, type injection
** TODO gathering used types and procedures
** TODO type normalization
** TODO translation from Nim IR to GLSL
** TODO identifier transformation
*** underscore separator
*** collision prevention with glsl keywords
** TODO AST pattern matching
** TODO matching the for construct

* base example

# Why I chose an example for explanation?
To my knowledge it is easiest to understand a new topic with a
concrete example.  Therefore I would like to explain the inernals of
the compiler with an example.  The example that I choose should be an
example that is easy to understand, could be part of a real program
and it should cover many features that I want to support.

# What is the example about?
In listing ref:base-example I show an example that I want to make
executable over the course of this mater thesis.  It renders a mesh
with texture mapping and vertex-normals.  In the vertex shader the
lighting is calculated by a loop that iterates all light sources.

Features this example covers:

  * uniforms
  * attributes
  * non-builtin types (Light)
  * for loop (iterator)

#+caption: Base Example label:base-example
#+BEGIN_SRC nim
import glm, macros

macro render(args: varargs[untyped]): untyped =
  for arg in args:
    echo arg.treeRepr

type
  Mesh[T] = object
  Framebuffer[T] = object
  Texture2D = object

type
  MyFragmentType = object
    color: Vec4f

  MyVertexType = object
    position_os: Vec4f
    normal_os: Vec4f
    texCoord: Vec2f

  Light = object
    position_ws : Vec4f
    color : Vec4f

  MyMesh        = Mesh[MyVertexType]
  MyFramebuffer = Framebuffer[MyFragmentType]

var myTexture: Texture2D
var mesh: MyMesh
var framebuffer: MyFramebuffer
var mvp: Mat4f

var M,V,P: Mat4f
var lights: array[10,Light]

framebuffer.render(mesh) do (v, gl):
  gl.Position     = (P * V * M) * v.position_os
  let position_cs = V*M*v.position_os
  let normal_cs   = inverse(transpose(V*M)) * v.normal_os
  var lighting: Vec4f

  ## rasterize

  for light in lights:
    let light_position_cs = V * light.position_ws
    let light_direction_cs = light_position_cs-position_cs
    let light_intensity = dot(light_direction_cs, normal_cs)
    lighting += light_intensity * light.color

  let textureSample = texture(myTexture, v.texCoord)
  result.color = textureSample * lighting

#+END_SRC

** Type Checking Phase

The symbol ~render~ is the macro and the entire block including the
symbol ~framebuffer~ until the end of the macro is the argument of the
macro.  For now to keep the complexity low, I just assume that
every symbol inside of the AST can be resolved by the Nim type
checker.  There is a trick that I do to achieve this explained in more
detail in [[sec:two-layer-macro]].  The typechecked ast is very verbose in
its tree representation, but for the last two lines the AST looks like
the following.

#+BEGIN_SRC
    LetSection
      IdentDefs
        Sym "textureSample"
        Empty
        Call
          Sym "texture"
          Sym "myTexture"
          DotExpr
            Sym "v"
            Sym "texCoord"
          FloatLit 0.0
    Asgn
      DotExpr
        Sym "result"
        Sym "color"
      Infix
        Sym "*"
        Sym "textureSample"
        Sym "lighting"
#+END_SRC

# the AST structure
Each node is tagged with a node kind, for example ~LetSection~,
~Call~, ~DotExpression~, ~Sym~, etc, and each node has an arbitrary
amount of children. Some nodes have string values like symbols and
string literals. Also Literals also contain their value.

# additional information that is in the AST
Type information can not only be queried from symbol nodes, but also
from all expressions.  For example when ~getTypeInst~ is called on the
~Infix~ node in the excerpt above, it will return the type ast of
exactly that node.  Types are represented in AST form as well.  For
example the type ~Vec4f~ will be represented after normalization as
~Vec[4, float32]~.  Symbols also have a symbol tag (not visible
in the tree) that specifies what kind of symbol it is.  This tag can
be used to identify if a symbol is a type, a function, a variables, a
constant etc.  From type and function symbols it is possible to jump
to the AST of the implementation.

# TODO reference the type normalization section

From all the information that this AST provides, it is possible to
generate everything necessary to run that code on the GPU.

** vertex fragment shader separation

At the time of writing this, the magic comment ~## rasterize~ defines
the split point of vertex and fragment shader.  Everything before that
comment is defined to be part of the vertex shader, everything behind
it will be compiled into the fragment shader.

I don't necessarily like this magic comment, and I think eventually it
should go away. But the advantages of this magic comment are that it is
easy to understand and very easy to implement.  it serves its
purpose very well to split between vertex shader and fragment shader.

** Extraction of Meta Information

From all the information the AST provides several lists are extracted
that will be used for code generation

 * Uniforms :: Symbols of variables that appear in the body, but are
               not declared locally in that body, but come from
               somewhere else in the program.  These symbols need to
               be passed as uniforms to the program.

 * Attributes :: Each access to the vertex symbol is an access to an
                 attribute.  With this approach there won't be any
                 attribute passed to the shader that isn't used.

 * Types :: Types of symbols and expressions that are used within the
            body.  Types that are not built-in types of glsl need to
            be compiled to glsl.

 * Procedures :: Procedure symbols that are used within the
                 body. Procedures that are not built-in need to be
                 compiled to glsl as well.

 * Varyings :: Symbols that are declared in the vertex shader, but are
               accessed from the fragment shader are symbols that need
               to be rasterized as varying.

** passing uniforms

# how passing uniforms generally works and what should be taken care of.

When the shader program uses a symbol that is not locally defined
within the shader block, it has to be a passed to the shader as a
uniform.  It is known at compile time what symbols are used, how many
symbols are used, and what their type is, but it is not known at
compile time what value they have.  A matrix that is used could be a
new matrix uniform on each draw call, and a texture could be an
entirely different texture object on each draw call.  This needs to be
taken care of.  Generally I distinguish between two kinds of uniforms,
the plain old data uniforms, like matrices, vectors and scalars. And
texture uniforms that are represented by a handle on the client.  All
uniforms that are just plain old data can simply be passed to the
shader program in one block of binary data, the uniform buffer.  For
textures though, this does not work.  Putting the texture handle into
the uniform buffer does not work.  In OpenGL textures are not
passed directly to the shader.
Internally OpenGL has a list of active textures, the active texture
array.  A texture needs to be bound to an active texture first.  And
then the program that uses a textures needs to know the index of the
texture in the active texture array.  This is simply done by passing
an integer to the uniform.  I personally think that this list of
active textures is something the programmer should not need to worry
about.  The user/programmer should just be able to use a texture
symbol and it should work in all circumstances.

[[./images/active-texture.png]]

# how I pass my uniforms to the shader
So first of all, I split all the used uniform symbols into two
different kinds of uniforms, the /texture/ uniforms, and the
/non-texture/ uniforms. All /non-texture/ uniforms are automatically
joined into a single uniform buffer, which is then passed to the
program in one batch.

For textures I have a slightly different approach.  Since I know all
symbols statically, I assign each texture symbol to one position in
the active texture array at compile time.  So for example the first
used texture symbol will use ~GL_TEXTIRE0~ the second one will use
~GL_TEXTURE1~ etc.  This also won't change anymore at run-time, but
the actual value (handle) of the texture symbol can change at any time
during run-time, therefore I bind all texture handle on each draw call
to the list of active textures.  Since all textures are in a
consecutive array I can set them all at once with
~glBindImageTextures~.

There will never be a call to ~glUniform1i~ to set a texture
uniform before a draw call, texture handles can change at any time and
it will just work, and no programmer needs to spend time thinking
about the internal list of active textures.

#+BEGIN_SRC glsl
// here I start at 0, but I could start at any other index.
layout(binding=0) uniform sampler2D reflection;
layout(binding=1) uniform sampler2DShadow color;
layout(binding=2) uniform samplerCube skybox;
#+END_SRC

#+BEGIN_SRC nim
var handles = [reflection.handle, color.hanle, skybox.handle]
glBindTextures(0, GLsizei(handles.len), handles[0].addr)
#+END_SRC

A possible optimization to this method would be to reserve some active
textures at compile time for textures that are known to be used in
many shader programs.  These textures would be bound to active textures at
initialization stage and never unbound again.  For example just assume
a font atlas would be used by many programs.

#+BEGIN_SRC glsl
  // here are all used texture uniforms from the statically reserved
  // active textures
  layout(binding=0) uniform sampler2DRect fontAtlas;

  // the used active textures are now of course shifted by the total
  // amount of statically reserved active textures.  For the purpose of
  // this example I assume that there is another statically reserved
  // active texture in the program, that is not used in this shader. So
  // all used texture uniforms are shifted by 2 in the index.
  layout(binding=2) uniform sampler2D reflection;
  layout(binding=3) uniform sampler2DShadow color;
  layout(binding=4) uniform samplerCube skybox;
#+END_SRC

#+BEGIN_SRC nim
var handles = [reflection.handle, color.hanle, skybox.handle]
glBindTextures(2, GLsizei(handles.len), handles[0].addr)
#+END_SRC

The advantage here is that statically reserved active texture units
don't need any OpenGL state change at all.  But I have no measurement
at all on how much performance gain there is or much much performance
gain might be possible.

The disadvantage is for the mostly that the programmer needs to take
active care of these statically reserved active textures.  He needs to
be aware on how many there are. The limits are at least 48 by the
standard, and on my computer there cannot be more than 192 combined
texture image units. Also all texture unit reservation needs to take
place before the first shader program is compiled, because otherwise
the offset for the dynamically bound active textures won't be correct
anymore.

Because of the disadvantages and no guarantee for a performance gain,
this has not been implemented yet.  But this technique will be picked
up again, if binding textures turns out to be expensive.


** Translating Symbols to glsl

Translating symbols to glsl could be done just by writing the name of
the symbol to glsl. I could rename all symbols to generic names such
as ~sym1~, ~sym2~, ~sym3~, ... but this make the generated code very
hard to read.  And I would really like to be able to read the
generated code, just to verify that it is correct.  Whenever something
doesn't work and I need to check manually what went wrong in the code
generation process, it helps a lot when the generated code is readable
and maintains the names of the original symbols.

# underscores
Nim has a very weird rule for identifier equality.  First of all it is
case insensitive (except for the first character), and it ignores
underscores in names.  so ~foo_bar~ and ~fooBar~ are equal according
to Nim identifier comparison.  I don't necessarily like this but I can
use it to my advantage.  First of all I can remove all underscores
from identifires without creating name clashes from Nim symbols.  Then
the underscore becomes free for me to create prefixes and postfixes
that cannot clash at all anymore with other Nim symbols. For example I
can generate ~in_foobar~ and it cannot clash with a symbol from the
ast, because if ~in_foobar~ would be used inside of the body, it would
be translated without the ~_~, it would be translated as ~infoobar~.

# resolving keyword conflicts
Nim allows symbols to be named like keywords of glsl. This is
simply resolved with a list of all glsl keywords.  Whenever a symbol
name is a keyword in glsl, I will know that by looking in that list,
and I will append a post-fix to the generated symbol in glsl.

** Translating Types to glsl

# translating simple types to glsl
Most types that are used in the code block should be built-in types of
glsl, just the correct mapping of the types should be done. For
example the Nim type ~int32~ will be translated to ~int~ and ~float32~
will be translated to ~float~. A bit more complicated are the
vec-types.  For example the type ~Vec4f~ is an alias to
~Vec4[float32]~ which is also just an alias to ~Vec[4,float32]~.  For
this alias resolution I implemented a ~normalizeType~ function that
resolves all alias types to their original name.  In this case all of
the three representations would be mapped to ~Vec[4,float32]~.  The
generic Vec types are easy to map to the built-in types of glsl.  For
example ~Vec[4,float32]~ is translated to ~vec4~ and ~Vec[2, int32]~
is translated to ~ivec2~, etc.

# translating used defined types to glsl

For user defined types, the type definition needs to be translated to
glsl as well.  In the given example that would be the type ~Light~
that is used by iterating the lights array.  A simple check of that
symbol is a built-in types should verify that this type is a user
defined type.  With ~getImpl~ on the ~Light~ type symbol I can get to
the implementation and use it to translate it to glsl.  Here is an
example how the translation of that type looks like.

#+caption: Light Type Definition in Nim
#+BEGIN_SRC nim
type
  Light = object
    position_ws : Vec4f
    color : Vec4f
#+END_SRC

#+caption: Light Type AST from getImpl
#+BEGIN_SRC
ObjectTy
  Empty
  Empty
  RecList
    IdentDefs
      Sym "position_ws"
      Sym "Vec4f"
      Empty
    IdentDefs
      Sym "color"
      Sym "Vec4f"
      Empty
#+END_SRC

#+caption: Light Type in glsl
#+BEGIN_SRC glsl
struct Light {
  vec4 positionws;
  vec4 color;
};
#+END_SRC

Of course types that are used as members here need to be translated to
glsl as well, when they are not already built-in.  In this example
this is not necessary though, because ~vec4~ is a built-in type.

** working on the Framebuffer type

a frambeffure needs the following attributes

  * size :: each attachment needs to have this size
  * depth attachment :: can be DepthTexture or a DepthRenderbuffer
  * stencil attachment :: I don't know what it can be
  * color attachments :: these can be an arbitrary amount of
       attachments.

Each attachments needs to have the following information:
  * name :: each attachment needs to have a name
  * glsl type :: the type in glsl for the output variable
  * internal format :: how is it stored internally. float, normalized
       int, or something else. Also for the depth it specifies the
       precision
  * texture type :: what kind of texture is the color attachment?
                    Texture2D, Texture2DRect, Texture2DShadow, ...

Open questions

 * ownership :: who owns the attachments? Are the attachments created
                with the Framebuffer and die with it, or is the
                lifetime of the Attachment independent of the
                Framebuffer?

 * compile or run time :: Which information needs to be statically
      known at compile time for code generation. Which information
      needs to be statically known? Which information is best
      specified at runtime?


a Framebuffer as a depth




** the two layer macro
<<sec:two-layer-macro>>

# how the nim typechecker works, and why I create the outer macro.
The typechecker in Nim can only check types of the Nim programming
language with semantics of the Nim programming language.  The type
checking algorithm itself is not script-able.  Therefore I need to map
glsl semantics somehow to the Nim programming language.  Most glsl
types map nicely to the types defined in the glm library.  Then the
glsl part needs to have some context for the typechecker that I inject
with a two layer macro (where the full will you talk about it).

From here on I assume that all types of glsl also work flawlessly in
Nim.  For more details on how this works see the glsl section.

In order for the typecheck to be able to resolve all symbols correctly
I use the pattern with a two layer macro.  The outer macro takes a
non-type-checked AST, and then generates an AST that is capabale to be
fully type-checked.  The then generated AST is a statment to a typed
macro.  With this pattern it is possible to introduce symbols that
only exist in the embedded DSL.  In the listings ref:two-layer-macro-a
and ref:two-layer-macro-a you see how I introduce the symbol ~gl~ with
this pattern.

#+caption: Two Layer Macro A label:two-layer-macro-a
#+BEGIN_SRC nim
framebuffer.render(mesh) do (v):
  gl.Position     = (P * V * M) * v.position_os
  #[...]#
#+END_SRC

This will be transformed into the following statement:

#+caption: Two Layer Macro B label:two-layer-macro-b
#+BEGIN_SRC nim
block:  # A code block to create a new variable scope.
  gl: var GlShaderContext {.inject.} # inject to prevent symbol hiding hygienic
  render_inner(framebuffer, mesh) do (v: MyVertexType) -> MyFragmentType:
    gl.Position     = (P * V * M) * v.position_os
    #[ ... ]#
#+END_SRC

Now the type checker can resolve all symbols from the inner body of
this macro.  The typechecked AST is reprinted here again in nim representation.

#+BEGIN_EXAMPLE

do (v: MyVertexType; gl: var GlShaderContext) -> MyFragmentType:
  gl.Position = P * V * M * v.position_os
  let position_cs = V * M * v.position_os
  let normal_cs = inverse(transpose(V * M)) * v.normal_os
  var lighting: Vec4f
  block tmp346054:
      var light: Light
      var i = 0
      if i <= 9:
        block tmp346055:
            while true:
              light = lights[i]
              let light_position_cs = V * light.position_ws
              let light_direction_cs = light_position_cs - position_cs
              let light_intensity = dot(light_direction_cs, normal_cs)
              lighting += light_intensity * light.color
              if 9 <= i:
                break tmp346055
              inc(i, 1)
  let textureSample = texture(myTexture, v.texCoord, 0.0)
  result.color = textureSample * lighting

#+END_EXAMPLE

For representation alone it is not obvious that it is now a tree
of resolved symbols, but the full tree would be too large to be shown
here. This is only the last last line printed in tree representation:

#+BEGIN_EXAMPLE
  Asgn
    DotExpr
      Sym "result"
      Sym "color"
    Infix
      Sym "*"
      Sym "textureSample"
      Sym "lighting"

#+END_EXAMPLE

I don't know what to do to prevent that the for loop becomes a while
loop.  Should I filter for this while loop and translate it back to a
for loop in glsl? Or should I just translate into a while loop and
hope the glsl compiler will be able to unroll it anyway?  Glsl
performance might really suffer from dynamically sized arrays, but
this should really be tested,  I did not test it at all yet.

** preventing the `iterator items` expansion, or matching against it?

The metainformation that is important for the next steps are the
following:

 * split vertex and fragment shader parts
 * extract all used uniforms
 * extract all used attributes and in witch shader they are used
 * extract identifiers that are used as varyings.
 * used types (non glsl types)

*** Extract Vertex and Fragment Shader

**** TODO introduce name for the argument of the macro (the AST).

# How do I get metainformation.
# What uniforms are used
# What attributes are used
# how do I translate identifiers

** preventing the `iterator items` expansion, or matching against it?

From here on the Nim code should be translated directly into
GLSL. Even though I haven't talked at all about the shader stage
separation at all, and this is important.

* symbol table

| symbol             | kind         | glsl repr        | type                    |
|--------------------+--------------+------------------+-------------------------|
| inversse           | BuiltinProc  | inversse         |                         |
| transpose          | BuiltinProc  | transpose        |                         |
| texture            | BuiltinProc  | texture          |                         |
| dot                | BuiltinProc  | dot              |                         |
| vec4f              | BuiltinProc  | vec4             |                         |
| M                  | Uniform      | M                | Mat[4,float32]          |
| V                  | Uniform      | V                | Mat[4,float32]          |
| P                  | Uniform      | P                | Mat[4,float32]          |
| lights             | Uniform      | lights           | array[3,Light]          |
| v.position_os      | Attribute    | v_positionos     | Vec[4,float32]          |
| v.normal_os        | Attribute    | v_normalos       | Vec[4,float32]          |
| v.texCoord         | Attribute    | v_texCoord       | Vec[2,float32]          |
| result.color       | Result       | result_color     | Vec[4,float32]          |
| Vec4f              | Type         | vec4             | Vec[4,float32]          |
| Mat4f              | Type         | mat4             | Mat[4,float32]          |
| float32            | Type         | float            | float32                 |
| light              | LoopIt       | ???              | ???                     |
| position_ws        | Member       | positionws       | Light -> Vec[4,float32] |
| color              | Member       | color            | Light -> Vec[4,float32] |
| position_cs        | LocalVar     | positioncs       | Vec[4,float32]          |
| normal_cs          | LocalVar     | normalcs         | Vec[4,float32]          |
| lighting           | LocalVar     | lighting         | Vec[4,float32]          |
| light_position_cs  | LocalVar     | lightpositioncs  | Vec[4,float32]          |
| light_direction_cs | LocalVar     | lightdirectioncs | Vec[4,float32]          |
| light_intensity    | LocalVar     | lightintensity   | float32                 |
| textureSample      | LocalVar     | textureSample    | Vec[4,float32]          |
| t1                 | Intermediate | temp_1           | Mat[4,float32]          |
| t2                 | Intermediate | temp_2           | Mat[4,float32]          |
| t3                 | Intermediate | temp_3           | Mat[4,float32]          |
| t4                 | Intermediate | temp_4           | float32                 |
| t5                 | Intermediate | temp_5           | Vec[4,float32]          |
| t6                 | Intermediate | temp_6           | Vec[4,float32]          |
| t7                 | Intermediate | temp_7           | Vec[4,float32]          |

* intermediate representation

#+BEGIN_SRC

(Block
  (Asgn `gl.Position` (Mult `P` `V` `M` `v.position_os`))
  (Asgn `position_cs` (Mult `V` `M` `v.position_os`))
  (Asgn `t1` (Mult `V` `M`))
  (Asgn `t2` (Call `transpose` `t1`))
  (Asgn `t3` (Call `inverse` `t2`))
  (Asgn `normal_cs` (Mult `t3` `v.normal_os`))
  (Asgn `lighting`  (Call `vec4f` 0))
  (Loop `light` `lights`
    (Asgn `t4` (Dot `light` `position_ws`))
    (Asgn `light_position_cs` (Mult `V` `t4`))
    (Asgn `t5` (Neg `position_cs`))
    (Asgn `light_direction_cs` (Add `t5` `light_position_cs`))
    (Asgn `light_intensity`  (Call `dot` `light_direction_cs` `normal_cs`))
    (Asgn `t6` (Dot `light` `color`))
    (Asgn `t7` (Mult `light_intensity` `t6`))
    (Asgn `lighting` (Add `lighting` `t7`))
  )
  (Asgn `textureSample` (Call `texture` `myTexture` `v.texCoord`))
  (Asgn `result.color` (Mult `texturesample` `lighting`))
)

#+END_SRC


all symbols in the loop body need to be in a group, because a variable
in the loop body can't be passed down to the fragment shader.

* all <= relations

| `gl.Position`        | `P`                  |
| `gl.Position`        | `V`                  |
| `gl.Position`        | `M`                  |
| `gl.Position`        | `v.position_os`      |
| `position_cs`        | `V`                  |
| `position_cs`        | `M`                  |
| `position_cs`        | `v.position_os`      |
| `t1`                 | `V`                  |
| `t2`                 | `M`                  |
| `t2`                 | `t1`                 |
| `t3`                 | `t2`                 |
| `normal_cs`          | `t3`                 |
| `normal_cs`          | `v.normal_os`        |
| `t4`                 | `light`              |
| `t4`                 | `light`              |
| `light_position_cs`  | `V`                  |
| `light_position_cs`  | `t4`                 |
| `t5`                 | `position_cs`        |
| `light_direction_cs` | `t5`                 |
| `light_direction_cs` | `light_position_cs`  |
| `light_intensity`    | `light_direction_cs` |
| `light_intensity`    | `normal_cs`          |
| `t6`                 | `light`              |
| `t6`                 | `color`              |
| `t7`                 | `light_intensity`    |
| `t7`                 | `t6`                 |
| `lighting`           | `lighting`           |
| `lighting`           | `t7`                 |
| `textureSample`      | `myTexture`          |
| `textureSample`      | `v.texCoord`         |
| `result.color`       | `texturesample`      |
| `result.color`       | `lighting`           |


#+BEGIN_SRC nim

type
  IRNodeKinds = enum
    irBlock
    irAsgn
    irDot
    irMult
    irAdd
    irNeg
    irCall
    irDecl
    irLoop

#+END_SRC

* generated shader source

This is how the generated shader source could/should look like. This
code is hand translated, so it is not guaranteed that the final
compiler will generate exactly this shader code, but at the current
state of development it looks like this could be done.

** TODO talk about shader stage separation

#+BEGIN_SRC glsl
#version 450
uniform mat4 P;
uniform mat4 V;
uniform mat4 M;

in layout(location = 0) vec4 in_v_positionos;
in layout(location = 1) vec4 in_v_normalos;
in layout(location = 2) vec2 in_v_texCoord;

out layout(location = 0) vec4 out_positioncs;
out layout(location = 1) vec4 out_normalcs;
out layout(location = 2) vec2 out_v_texCoord;

void main() {
  vec4 v_positionos = in_v_positionos;
  vec4 v_normalos = in_v_positionos;
  vec2 v_texCoord = in_v_texCoord;

  gl_Position = P * V * M * v_positionos;
  vec4 positioncs = V * M * v_positionos;
  vec4 normalcs   = inverse(transpose(V * M)) * v_normalos;

  out_positioncs = positioncs;
  out_normalcs = normalcs;
  out_v_texCoord = v_texCoord;
}
#+END_SRC

#+BEGIN_SRC glsl
#version 450

uniform mat4 P;
uniform mat4 V;
uniform mat4 M;
uniform sampler2D myTexture;

struct Light {
  vec4 positionws;
  vec4 color;
};

uniform Light lights[10];

in layout(location = 0) vec4 in_positioncs;
in layout(location = 1) vec4 in_normalcs;
in layout(location = 2) vec2 in_v_texCoord;

out layout(location = 0) vec4 result_color;

void main() {
  vec4 positioncs = in_positioncs;
  vec4 normalcs = in_normalcs;
  vec2 v_texCoord = in_v_texCoord;

  vec4 lighting = vec4(0);

  for(int i = 0; i < 10; ++i) {
    Light light = lights[i];
    vec4 lightpositioncs = V * light.positionws;
    vec4 lightdirectioncs = lightpositioncs - positioncs;
    float light_intensity = dot(lightdirectioncs, normalcs);
    lighting += light_intensity * light.color;
  }

  vec4 textureSample = texture(myTexture, v_texCoord, 0.0);
  result_color = textureSample * lighting;
}
#+END_SRC

 * how do I map symbols/identifiers.

I take out all the _ underscore charactors. They do not have any
meaning in Nim anyway. Then I can use it for my own personal
separation in glsl.


additionally to the shader code, the following OpenGL commands should be
generated:

 * glCompileShader
 * glLinkShader
 * glUninform
 * glAttribute
 * glDraw
 * etc (details you don't wanna know, but I have to fill pages, maybe
   you will get to know them even if you don't want to)

* other example

#+BEGIN_SRC nim
render myVA: (vs, gl) ->

    # face normal test
    let normal = normalize cross(v[0].pos - v[1].pos, v[0].pos - v[2].pos)
    for 1..5:
        for 1..3:
            emit proj * view * model * v.position
        endPrimitive

    # per vertex -> line in vertex normal dir
    var color: Vec3
    var normal: Vec3
    for v in vs:
        for i in 0..1:
            normal = v.normal
            color = if i == 0: vec3(1,0,0) else: vec3(0,0,1)
            emit proj * view * model * (v.position + vec4(v.normal, 0) * i)
        endPrimitive

    result.color = dot(color, normal)


    # per vertex -> line in vertex normal dir
    for v in vs:
        for i in 0..1:
            gl.Position = proj * view * model * (v.position + vec4(v.normal, 0) * i)
            let normal = v.normal
            let color = if i == 0: vec3(1,0,0) else: vec3(0,0,1)
            result.color = dot(color,normal)
            emitVertex()
        endPrimitive(GL_LINE_STRIP)


    # per vertex -> line in vertex normal dir
    for v in vs:

        gl.Position = proj * view * model * (v.position + vec4(v.normal, 0) * i)
        let normal = v.normal
        let color = vec3(1,0,0)
        result.color = dot(color,normal)
        emitVertex()

        gl.Position = proj * view * model * (v.position + vec4(v.normal, 0) * i)
        let normal = v.normal
        let color = vec3(0,0,1)
        result.color = dot(color,normal)
        emitVertex()

        endPrimitive(GL_LINE_STRIP)

#+END_SRC
* mesh type



what the Mesh needs to provide

 * hold references to all its per vertex data
 * provide an automatic way to bind its data to the shader program
 * provide metainformation for the compiler, for example the vertex
   type for the shader interface.
 * allow flexibility for attributes, interleaved, separate buffers,
   and Hybrid.

OpenGL has kind of a solution for this concept, the
VertexArrayObject. So in theory everything is specified in the vertex
array object and everything can be set with a single call to
~glBindVertexArray~. But there is a problem. The format that is set
with ~glVertexAttribFormat~ for each vertex attribute index /format/
sets a state in the VertexArrayObject.  For me this is a conflict,
because the program should be responsible for allocating attribute
indices, not a vertex array object.  When the mesh type is defined, it
is not yet known with how many attributes it will later be rendered.
Only the program (the render macro) knows all of the attributes.  I
would like to keep the option open for the program to pull in more
attributes than the ones that are specified by a single mesh.

Just an example for this use case is the following.  Imagine you would
like to render a sphere on each vertex of the rocker arm mesh (this is
done in OpenFlipper).  The ideal solution would be to use the vertex
array of the rocker arm mesh and use it as instancing information for
the shpere mesh.  But when both meshes independently gave away
attribute 0, then things might become a bit ugly.  I would not want to
offload the attribute index allocation to the user.  But there is a
solution that works for my system.  There is a solution for this
problem though.

I always take the program and a vertex array object as an indivisible
pair, and call that my program.  Then the format and index is again an
attribute of the program.  But then the mesh explicitly does not have
a vertex array object, only a list of buffers and a way to provide
metainformation to it.  The actual buffers that are used for rendering
are bound on each frame with ~glVertexArrayVertexBuffers~.  This allows
to bind all attribute buffers fast and per frame in a
single call, the only constraint is that all buffers that I bind this
way need to bound to a continuous ranged of binding points (currently
for simplicity attribute binding points and attribute indices are set
to be identical, this makes things simpler, and no they don't help
here either).

void glVertexArrayVertexBuffers(	GLuint vaobj,
 	GLuint first,
 	GLsizei count,
 	const GLuint *buffers,
 	const GLintptr *offsets,
 	const GLsizei *strides);
